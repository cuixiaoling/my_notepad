思考：
· Vue.js 究竟是如何在我们对数据进行操作的时候影响视图的呢？？
· 修改的数据是如何批量高效地映射到视图上呢？
· 传统的DOM操作又在何时进行的呢？

object.defineProterty

运行时编译 template
预编译 render function

(一)编译 compile()

parse 解析 - 从语法上解析
用正则等方式解析 template 模板中的指令，class style等数据
形成 AST

optimize 优化

标记static 静态节点，这是Vue在编译过程中的一处优化，
后面当update更新界面时，会有一个patch（补丁）的过程，
diff算法会直接跳过静态节点，从而减少了比较的过程，优化了patch的性能

generate 生成

generate 是将AST转化 转化成 render function 字符串的过程，得到的结果是
render 的字符串以及 staticRenderFns 字符串。

在经历过 parse optimize generate 这三个阶段后，组件中就会存在渲染
VNode 所需的 render function 

(二)响应式

这里的 getter和setter 已经在之前介绍过了，在init的时候通过
object.defineProperty 进行绑定，它使得当被设置的对象被读取的时候
会执行getter 函数，而被赋值的时候会执行 setter 函数。

当render function 被渲染的时候，因为会读取所需对象的值，所以会触发
getter 函数进行【依赖收集】，【依赖收集】的目的是将观察者Watcher对象
存放到当前闭包中的订阅者 Dep 的Subs 中。形成如下所示的一个关系

					Watcher1
				/	Watcher2
					...
			Dep
		 /
		/
object

在修改对象的值的时候，会触发对应的setter，setter通知之前【依赖收集】
的到的Dep中的每一个Watcher，告诉它们自己的值改变了，需要重新渲染视图。
这时候这些Watcher就会开始调用updata 来更新视图，
当然这中间还有一个patch的过程以及使用队列来异步更新的策略，

(三) Virtual DOM -虚拟DOM树
render function 会被转化成 VNode节点。Virtual DOM 其实就是一颗以JavaScript
对象（VNode 节点）作为基础的树，用对象属性来描述节点，实际上它只是一层对真实DOM
的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。由于Virtual DOM 是以JavaScript
对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、weex、Node等。
(四) 更新视图

第二节
响应式系统的基本原理

Vue.js 是一款MVVM框架，数据模型仅仅是普通的JavaScript对象，
但是对这些对象进行操作时，却能影响对应视图，它的核心实现就是
【响应式系统】。尽管我们在使用Vue.js进行开发时不会直接修改【响应式系统】
