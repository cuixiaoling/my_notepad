//闭包 如何使用闭包
let arr= [1,2,3,4]
for(let i=0; i<arr.length;i++){

}

//如何充分利用异步

回调 异步的基础
promise 是JavaScript和DOM提供异步返回值的正式方法
异步DOM api 
生成器

程序的一部分现在运行，一部分将来运行

现在和将来之间有段间隙，在这段间隙中，程序没有活跃执行

ps：异步请求数据：等待用户输入，从数据库文件系统中请求数据，通过网络
	动画

异步编程的核心：程序中现在运行的部分和将来运行的部分之间的关心\

异步到底是怎么出现的？？？
为什么会出现？？？
处理异步的其他方法？？

回调函数

函数返回值~~

1·1分块程序

可以把 javaScript 程序写在 

问题：程序中将来执行的部分，不一定是在现在运行的部分执行完之后  就立即执行

ajax("http://some.url.1",function myCallbackFunction(data){
	console.log(data)
})

避免回调函数引起的混乱

宿主环境  类型与语法 I/O 是非常低速的阻塞部分

浏览器在后台异步处理控制台I/O能够提高性能
JSON.stringify() -- 变成字符串
JSON.parse() --变成对象

1·2 事件循环



Javascript 引擎本身所做的只不过是在需要的时候，
在给定任意时执行程序中的单个代码块 

JavaScript引擎并不是独立运行的，它运行在宿主环境中，
对多数开发者来说通常是web浏览器

所有这些环境都有一个共同的点，线程，提供一种机制来处理程序中多块的执行，且执行每块的时调用JavaScript引擎，这种机制被称为事件循环

javascript引擎本身没有时间概念，只是一个按需执行JavaScript任意代码的环境。
事件（javascript 代码执行）调度总是由包含它的环境进行
ps:
var eventLoop = [];
var event;
while(true){
	if(eventLoop.length>0){
		event = eventLoop.shift();
		try{
			event()
		}
		catch(err){
			//console.log(err)
			reportError(err);
		}
	}
}
有一个用while 循环实现的持续运行的循环，循环的每一轮称为tick，
对每个tick而言，如果在队列中有等待事件，那么就会从队列中摘下一个事件并执行。
这些事情就是你的回调函数
setTImeout 并没有把你的事件放在循环队列中。它所做的是设定一个定时器。
当定时器到时间后，环境会把你的回调函数放在事件循环中，这样未来的某个时刻的tick
会摘下并执行这个回调
如果事件循环中已经有20个项目。你的回调就会等待，它得排在其他项目之后

程序通常分成了许多小块，在事件循环队列中一个接一个地执行。严格地说，
和你的程序不直接相关的其他事件也可能会插入到队列中

ES6 从本质上改变了在哪里管理事件循环。精确指定了事件循环的工作细节，
这意味着在技术上将其纳入了JavaScript引擎势力范围，而不是只由宿主环境来管理。
这个改变的一个主要原因是ES6中Promise的引入。因此这项技术要求对事件循环队列
的调度运行能够直接进行精细控制

1·3 并行线程
异步：是关于现在和将来的时间间隙
并行：关于能够同时发生的事情


并行计算最常见的工具是：进程和线程 ------------蒙~
进程和线程独立运行，并可能同时运行：在不同的处理器，甚至不同的计算机上
但多个线程能够共享单个进程的内存
与之相对的是，事件循环把自身的工作分为一个一个任务并顺序执行。


function later(){
	answer = answer *2;
	console.log("Meaing of life",answer);
}

单线程环境中，线程队列中的这些项目是底层运算确实是无所谓的，
因为线程本身不会被中断。
但如果是在并行系统中，同一个程序中
可能有两个不同的线程在运转，这时很可能就会得到不确定的结果

var a=20;
function foo(){
	a=a+1;
}
多线程并行

防止中断，和交错运行
JavaScript从不跨线程共享数据，这意味着不需要考虑
并行线程的交替执行和异步事件的交替调度，其粒度是完全不同的
ps:
javaScript 单线程 完整运行
不确定性是在函数(事件)顺序级别上，而不是多线程情况下的语句顺序级别
这种函数的不确定性就是通常所说的竟态条件
foo() 和 bar() 相互竞争，看谁先运行
因为无法可靠预测a和b的最终结果，所以才是竟态条件

如果 javaScript 的 某个函数由于某种原因不具有完整运行特性，
那么可能的结果就会多得多---ES6

1·4 并发
点击-Ajax
同时进行
JavaScript 一次只能处理一个事件
单线程事件循环是并发的一种形式（当然还有其他形式，后面会介绍）。
1，非交互，
两个或多个“进程”在同一个程序内并发地交替运行他们的步骤/事件时，
如果这些任务彼此不相关，就不一定需要交互。如果进程间没有影响的话，
不确定性是完全可以接受的。
2，交互
3，协作
//遍历数组
data.map(function(val){
	return val*2;
})
完整运行，前一个任务时间长，会影响后面的任务运行
创建一个 协作性更强更友好 且不霸占事件循环队列的并发系统
ps：异步批处理这些结果。每次处理之后返回事件循环，让其他等待事件有机会运行

1·5 任务
ES6 任务队列， Promise 异步特性
在事件循环的每个tick中，可能出现的异步动作不会导致
一个完整的新事件添加到事件循环队列中，而会在当前tick
的任务队列末尾添加一个任务
// 理论上的"任务API"
schedule( function(){
	console.log( "C" );
	schedule( function(){
		console.log( "D" );
	} );
} );
任务处理是在当前事件循环 tick结尾处，
且定时器触发是为了调度下一个事件循环tick
事件循环 任务队列
1·6 语句循环
//编译器对语句的重排
javaScript语言让我们不会见到编译器语句的重排序可能导致的噩梦，
这是一种幸运，但是代码编写的方式（从上到下的模式）和编译后执行的
方式之间的联系非常脆弱，

异步貌似是并行执行多个任务

2 - 回调
listen( "click", function handler(evt){
	setTimeout( function request(){
		ajax( "http://some.url.1", function response(text){
			if (text == "hello") {
			handler();
			}
			else if (text == "world") {
			request();
		}
		} );
	}, 500) ;
} );
doA( function(){
	doB();
	doC( function(){
		doD();
	} )
	doE();
} );
doF();
listen( "click", handler );     
function handler() {			
	setTimeout( request, 500 );
}
function request(){				
	ajax( "http://some.url.1", response );
}
function response(text){		
	if (text == "hello") {
		handler();
	}
	else if (text == "world") {
		request();
	}
}
异步函数回调的组成